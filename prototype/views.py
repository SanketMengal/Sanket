import json
import requests
import os
import time
import subprocess
import tempfile
import base64

from django.shortcuts import render, redirect
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required  # Make sure this import is present

# --- Important Security Note ---
# It's a best practice to store sensitive data like API keys
# in environment variables. This prevents them from being
# committed to version control.
# For this example, we'll use a placeholder. In production, you would
# get this value from an environment variable.
# Example: API_KEY = os.environ.get("GEMINI_API_KEY")
API_KEY = "" # Your API key will go here.
API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key="

@login_required(login_url='login')  # This is the correct way to apply the decorator
def index(request):
    """
    Renders the main index page of the application, but only if the user is authenticated.
    """
    # The decorator handles the redirection automatically, so the manual check is not needed.
    return render(request, 'prototype/index.html')

# -----------------------------------------------------------------------------
# Authentication views
# -----------------------------------------------------------------------------
def login_view(request):
    """
    Handles user login. Renders the login form for GET requests and
    authenticates the user for POST requests.
    """
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)

        if user is not None:
            # The user is a valid user and is active
            login(request, user)
            return redirect('index') # Redirect to the homepage on successful login
        else:
            # Authentication failed, return to the login page with an error message
            return render(request, 'prototype/login.html', {'error': 'Invalid username or password'})
    
    # For a GET request, just display the login page
    return render(request, 'prototype/login.html')

def logout_view(request):
    """
    Logs out the current user and redirects them to the login page.
    """
    logout(request)
    return redirect('login')

# -----------------------------------------------------------------------------
# Existing functions remain unchanged
# -----------------------------------------------------------------------------

def json_to_mermaid_syntax(data):
    """
    Converts a JSON object (as generated by the LLM) into a Mermaid.js syntax string.
    
    Args:
        data (dict): The dictionary containing diagram data (diagramType, nodes, edges).
        
    Returns:
        str: The Mermaid syntax string, or an empty string if conversion fails.
    """
    diagram_type = data.get('diagramType', '').lower()
    
    mermaid_code = ""

    if diagram_type == 'flowchart':
        mermaid_code = "graph TD\n"
        for edge in data.get('edges', []):
            from_node = edge.get('from')
            to_node = edge.get('to')
            mermaid_code += f"    {from_node} --> {to_node}\n"
    elif diagram_type == 'sequence':
        mermaid_code = "sequenceDiagram\n"
        for edge in data.get('edges', []):
            from_node = edge.get('from')
            to_node = edge.get('to')
            mermaid_code += f"    {from_node} ->> {to_node}: action\n"
    elif diagram_type == 'class':
        mermaid_code = "classDiagram\n"
        for edge in data.get('edges', []):
            from_node = edge.get('from')
            to_node = edge.get('to')
            mermaid_code += f"    {from_node} <|-- {to_node}\n"
            
    # Add node definitions with their text
    for node in data.get('nodes', []):
        node_id = node.get('id')
        node_text = node.get('text')
        # Use an HTML-like syntax for the node text in Mermaid
        if node_id and node_text:
            mermaid_code += f"    {node_id}[{node_text}]\n"

    return mermaid_code

@csrf_exempt
@require_POST
def generate_diagram(request):
    """
    Handles a POST request, sends a prompt to the Gemini API,
    converts the JSON response to Mermaid syntax, and then
    uses mermaid-cli to generate an image.
    """

    # Add a check to ensure the user is logged in for API calls.
    if not request.user.is_authenticated:
        return JsonResponse({'error': 'Unauthorized: Please log in to use this feature.'}, status=401)
    
    try:
        data = json.loads(request.body.decode('utf-8'))
        user_prompt = data.get('prompt')

        if not user_prompt:
            return JsonResponse({'error': 'Prompt is missing from the request body.'}, status=400)

        print(f"Received prompt: {user_prompt}")

        system_instruction = (
            "You are a helpful assistant that generates JSON data for diagrams. "
            "The user will provide a text prompt describing a diagram. "
            "Your response must be a valid JSON object with the following structure: "
            "{'diagramType': 'flowchart' or 'sequence' or 'class', 'title': 'The Diagram Title', 'nodes': [{'id': 'unique-id', 'text': 'Node Description'}...], 'edges': [{'from': 'source-id', 'to': 'target-id'}...]}"
            "Ensure the JSON is well-formed and ready for parsing. Do not include any text outside the JSON object."
        )

        payload = {
            "contents": [
                {
                    "role": "user",
                    "parts": [
                        {"text": system_instruction},
                        {"text": f"Generate a diagram for: {user_prompt}"}
                    ]
                }
            ],
            "generationConfig": {
                "responseMimeType": "application/json",
                "responseSchema": {
                    "type": "OBJECT",
                    "properties": {
                        "diagramType": {"type": "STRING"},
                        "title": {"type": "STRING"},
                        "nodes": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {
                                    "id": {"type": "STRING"},
                                    "text": {"type": "STRING"}
                                }
                            }
                        },
                        "edges": {
                            "type": "ARRAY",
                            "items": {
                                "type": "OBJECT",
                                "properties": {
                                    "from": {"type": "STRING"},
                                    "to": {"type": "STRING"}
                                }
                            }
                        }
                    }
                }
            }
        }
        
        max_retries = 3
        backoff_factor = 1
        response = None
        for i in range(max_retries):
            try:
                response = requests.post(f"{API_URL}{API_KEY}", json=payload)
                response.raise_for_status()
                break
            except requests.exceptions.RequestException as e:
                print(f"Attempt {i + 1} failed: {e}")
                if i < max_retries - 1:
                    sleep_time = backoff_factor * (2 ** i)
                    print(f"Retrying in {sleep_time} seconds...")
                    time.sleep(sleep_time)
                else:
                    raise

        if response is None or response.status_code != 200:
            return JsonResponse({'error': f'LLM API returned an error: {response.text}'}, status=response.status_code)

        result = response.json()
        print(f"LLM API response: {json.dumps(result, indent=2)}")

        generated_json_str = result['candidates'][0]['content']['parts'][0]['text']
        diagram_data = json.loads(generated_json_str)

        # ---------------------------------------------------------------------
        # NEW: Convert the LLM's JSON output to Mermaid syntax
        # ---------------------------------------------------------------------
        mermaid_syntax = json_to_mermaid_syntax(diagram_data)
        
        # ---------------------------------------------------------------------
        # NEW: Use mermaid-cli (mmdc) to generate the diagram image
        # ---------------------------------------------------------------------
        # Create a temporary file for the Mermaid code
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.mmd', encoding='utf-8') as mmd_file:
            mmd_file.write(mermaid_syntax)
            mmd_file_path = mmd_file.name

        # Create a temporary file for the output image (PNG)
        png_output_path = mmd_file_path.replace('.mmd', '.png')

        # Build and execute the command to run mermaid-cli
        command = ['mmdc', '-i', mmd_file_path, '-o', png_output_path]
        try:
            # `check=True` will raise an exception if the command fails
            # `capture_output=True` captures stdout and stderr
            subprocess.run(command, check=True, capture_output=True, text=True, encoding='utf-8')
        except subprocess.CalledProcessError as e:
            return JsonResponse({
                'error': f"Mermaid CLI failed. Check the Mermaid syntax or installation. Error: {e.stderr}",
                'mermaid_code': mermaid_syntax
            }, status=500)
        except FileNotFoundError:
            return JsonResponse({'error': 'mermaid-cli (mmdc) not found. Is it installed globally and in your PATH?'}, status=500)

        # Read the generated PNG file
        with open(png_output_path, 'rb') as png_file:
            image_data = png_file.read()

        # Encode the image data in Base64
        encoded_image = base64.b64encode(image_data).decode('utf-8')

        # Clean up temporary files
        os.remove(mmd_file_path)
        os.remove(png_output_path)

        # Return the Base64-encoded image
        return JsonResponse({'image_data': encoded_image})

    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON in request body or LLM response.'}, status=400)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return JsonResponse({'error': f'An internal server error occurred: {e}'}, status=500)